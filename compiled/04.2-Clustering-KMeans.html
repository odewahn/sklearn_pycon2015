<p><small><i>This notebook was put together by <a href='http://www.vanderplas.com'>Jake Vanderplas</a> for PyCon 2015. Source and license info is on <a href='https://github.com/jakevdp/sklearn_pycon2015/'>GitHub</a>.</i></small></p>
<section data-type='chapter'>
<h1>Clustering: K-Means In-Depth</h1>

<p>Here we'll explore <strong>K Means Clustering</strong>, which is an unsupervised clustering technique.</p>
<p>We'll start with our standard set of initial imports</p>
<pre data-code-language='python' data-executable='true' data-type='programlisting'>
%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

# use seaborn plotting defaults
import seaborn as sns; sns.set()
</pre>

<section data-type='sect1'>
<h1>Introducing K-Means</h1>

<p>K Means is an algorithm for <strong>unsupervised clustering</strong>: that is, finding clusters in data based on the data attributes alone (not the labels).</p>
<p>K Means is a relatively easy-to-understand algorithm.  It searches for cluster centers which are the mean of the points within them, such that every point is closest to the cluster center it is assigned to.</p>
<p>Let's look at how KMeans operates on the simple clusters we looked at previously. To emphasize that this is unsupervised, we'll not plot the colors of the clusters:</p>
<pre data-code-language='python' data-executable='true' data-type='programlisting'>
from sklearn.datasets.samples_generator import make_blobs
X, y = make_blobs(n_samples=300, centers=4,
                  random_state=0, cluster_std=0.60)
plt.scatter(X[:, 0], X[:, 1], s=50);
</pre>

<p>By eye, it is relatively easy to pick out the four clusters. If you were to perform an exhaustive search for the different segmentations of the data, however, the search space would be exponential in the number of points. Fortunately, there is a well-known <em>Expectation Maximization (EM)</em> procedure which scikit-learn implements, so that KMeans can be solved relatively quickly.</p>
<pre data-code-language='python' data-executable='true' data-type='programlisting'>
from sklearn.cluster import KMeans
est = KMeans(4)  # 4 clusters
est.fit(X)
y_kmeans = est.predict(X)
plt.scatter(X[:, 0], X[:, 1], c=y_kmeans, s=50, cmap='rainbow');
</pre>

<p>The algorithm identifies the four clusters of points in a manner very similar to what we would do by eye!</p>
</section>
<section data-type='sect1'>
<h1>The K-Means Algorithm: Expectation Maximization</h1>

<p>K-Means is an example of an algorithm which uses an <em>Expectation-Maximization</em> approach to arrive at the solution.
<em>Expectation-Maximization</em> is a two-step approach which works as follows:</p>
<ol>
<li>Guess some cluster centers</li>
<li>Repeat until converged
A. Assign points to the nearest cluster center
B. Set the cluster centers to the mean</li>
</ol>
<p>Let's quickly visualize this process:</p>
<pre data-code-language='python' data-executable='true' data-type='programlisting'>
from fig_code import plot_kmeans_interactive
plot_kmeans_interactive();
</pre>

<p>This algorithm will (often) converge to the optimal cluster centers.</p>
<section data-type='sect2'>
<h2>KMeans Caveats</h2>

<p>The convergence of this algorithm is not guaranteed; for that reason, scikit-learn by default uses a large number of random initializations and finds the best results.</p>
<p>Also, the number of clusters must be set beforehand... there are other clustering algorithms for which this requirement may be lifted.</p>
</section>
</section>
<section data-type='sect1'>
<h1>Application of KMeans to Digits</h1>

<p>For a closer-to-real-world example, let's again take a look at the digits data. Here we'll use KMeans to automatically cluster the data in 64 dimensions, and then look at the cluster centers to see what the algorithm has found.</p>
<pre data-code-language='python' data-executable='true' data-type='programlisting'>
from sklearn.datasets import load_digits
digits = load_digits()
</pre>

<pre data-code-language='python' data-executable='true' data-type='programlisting'>
est = KMeans(n_clusters=10)
clusters = est.fit_predict(digits.data)
est.cluster_centers_.shape
</pre>

<p>We see ten clusters in 64 dimensions. Let's visualize each of these cluster centers to see what they represent:</p>
<pre data-code-language='python' data-executable='true' data-type='programlisting'>
fig = plt.figure(figsize=(8, 3))
for i in range(10):
    ax = fig.add_subplot(2, 5, 1 + i, xticks=[], yticks=[])
    ax.imshow(est.cluster_centers_[i].reshape((8, 8)), cmap=plt.cm.binary)
</pre>

<p>We see that <em>even without the labels</em>, KMeans is able to find clusters whose means are recognizable digits (with apologies to the number 8)!</p>
<p>The cluster labels are permuted; let's fix this:</p>
<pre data-code-language='python' data-executable='true' data-type='programlisting'>
from scipy.stats import mode

labels = np.zeros_like(clusters)
for i in range(10):
    mask = (clusters == i)
    labels[mask] = mode(digits.target[mask])[0]
</pre>

<p>For good measure, let's use our PCA visualization and look at the true cluster labels and K-means cluster labels:</p>
<pre data-code-language='python' data-executable='true' data-type='programlisting'>
from sklearn.decomposition import PCA

X = PCA(2).fit_transform(digits.data)

kwargs = dict(cmap = plt.cm.get_cmap('rainbow', 10),
              edgecolor='none', alpha=0.6)
fig, ax = plt.subplots(1, 2, figsize=(8, 4))
ax[0].scatter(X[:, 0], X[:, 1], c=labels, **kwargs)
ax[0].set_title('learned cluster labels')

ax[1].scatter(X[:, 0], X[:, 1], c=digits.target, **kwargs)
ax[1].set_title('true labels');
</pre>

<p>Just for kicks, let's see how accurate our K-Means classifier is <strong>with no label information:</strong></p>
<pre data-code-language='python' data-executable='true' data-type='programlisting'>
from sklearn.metrics import accuracy_score
accuracy_score(digits.target, labels)
</pre>

<p>80% â€“ not bad! Let's check-out the confusion matrix for this:</p>
<pre data-code-language='python' data-executable='true' data-type='programlisting'>
from sklearn.metrics import confusion_matrix
print(confusion_matrix(digits.target, labels))

plt.imshow(confusion_matrix(digits.target, labels),
           cmap='Blues', interpolation='nearest')
plt.colorbar()
plt.grid(False)
plt.ylabel('true')
plt.xlabel('predicted');
</pre>

<p>Again, this is an 80% classification accuracy for an <strong>entirely unsupervised estimator</strong> which knew nothing about the labels.</p>
</section>
<section data-type='sect1'>
<h1>Example: KMeans for Color Compression</h1>

<p>One interesting application of clustering is in color image compression. For example, imagine you have an image with millions of colors. In most images, a large number of the colors will be unused, and conversely a large number of pixels will have similar or identical colors.</p>
<p>Scikit-learn has a number of images that you can play with, accessed through the datasets module. For example:</p>
<pre data-code-language='python' data-executable='true' data-type='programlisting'>
from sklearn.datasets import load_sample_image
china = load_sample_image("china.jpg")
plt.imshow(china)
plt.grid(False);
</pre>

<p>The image itself is stored in a 3-dimensional array, of size <code>(height, width, RGB)</code>:</p>
<pre data-code-language='python' data-executable='true' data-type='programlisting'>
china.shape
</pre>

<p>We can envision this image as a cloud of points in a 3-dimensional color space. We'll rescale the colors so they lie between 0 and 1, then reshape the array to be a typical scikit-learn input:</p>
<pre data-code-language='python' data-executable='true' data-type='programlisting'>
X = (china / 255.0).reshape(-1, 3)
print(X.shape)
</pre>

<p>We now have 273,280 points in 3 dimensions.</p>
<p>Our task is to use KMeans to compress the <span class='math-tex' data-type='tex'>\(256^3\)</span> colors into a smaller number (say, 64 colors). Basically, we want to find <span class='math-tex' data-type='tex'>\(N_{color}\)</span> clusters in the data, and create a new image where the true input color is replaced by the color of the closest cluster.</p>
<pre data-code-language='python' data-executable='true' data-type='programlisting'>
# reduce the size of the image for speed
image = china[::3, ::3]
n_colors = 64

X = (image / 255.0).reshape(-1, 3)

model = KMeans(n_colors)
labels = model.fit_predict(X)
colors = model.cluster_centers_
new_image = colors[labels].reshape(image.shape)
new_image = (255 * new_image).astype(np.uint8)

# create and plot the new image
with sns.axes_style('white'):
    plt.figure()
    plt.imshow(image)
    plt.title('input')

    plt.figure()
    plt.imshow(new_image)
    plt.title('{0} colors'.format(n_colors))
</pre>

<p>Compare the input and output image: we've reduced the <span class='math-tex' data-type='tex'>\(256^3\)</span> colors to just 64.</p>
</section>
</section>